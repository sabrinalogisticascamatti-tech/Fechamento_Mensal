import React, { useState, useEffect, useMemo, useRef } from 'react';
import { 
  LayoutDashboard, 
  UploadCloud, 
  FileText, 
  TrendingUp, 
  TrendingDown, 
  DollarSign, 
  Trash2, 
  Activity,
  Building2,
  PlusCircle,
  Settings,
  Edit2,
  ChevronRight,
  ChevronDown,
  ChevronLeft,
  Save,
  X,
  Filter,
  Calendar,
  ArrowUpCircle,
  ArrowDownCircle,
  Loader2,
  Sparkles,
  Bot,
  RefreshCw,
  Send,
  MessageSquare,
  List,
  FileUp,
  Factory,
  Target,
  BarChart3,
  Package,
  Wallet,
  Coins,
  Box,
  Calculator,
  PieChart as PieChartIcon,
  AlertTriangle,
  TableProperties,
  Search,
  Moon,
  Sun,
  Menu
} from 'lucide-react';
import { 
  BarChart, 
  Bar, 
  XAxis, 
  YAxis, 
  CartesianGrid, 
  Tooltip, 
  Legend, 
  ResponsiveContainer, 
  PieChart, 
  Pie, 
  Cell,
  LineChart,
  Line,
  ComposedChart,
  AreaChart,
  Area
} from 'recharts';

// Firebase Imports
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from 'firebase/auth';
import { 
  getFirestore, 
  collection, 
  addDoc, 
  getDocs, 
  deleteDoc, 
  doc, 
  updateDoc, 
  writeBatch 
} from 'firebase/firestore';

/**
 * ------------------------------------------------------------------
 * 0. CONFIGURATIONS (Firebase & Gemini)
 * ------------------------------------------------------------------
 */
const firebaseConfig = JSON.parse(__firebase_config);
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const appId = typeof __app_id !== 'undefined' ? __app_id : 'financial-saas-default';

// Gemini API Configuration
const apiKey = ""; 

/**
 * ------------------------------------------------------------------
 * 1. MASTER DATA & CONSTANTS (Defined Globally to fix ReferenceErrors)
 * ------------------------------------------------------------------
 */
const STANDARD_ORGANIZATION = [
  { group: 'Portos de Areia', units: ['Mineração Água Amarela', 'Porto de Areia Saara'] },
  { group: 'Pedreiras', units: ['Mineração Noroeste Paulista - Monções', 'Mineração Grandes Lagos - Icém', 'Mineração Grandes Lagos - Itapura', 'Mineração Grandes Lagos - Riolândia', 'Mineração Grandes Lagos - Três Fronteiras', 'Noromix Concreto - Rinópolis'] },
  { group: 'Usinas de Asfalto', units: ['Noromix Concreto - Rinópolis', 'Noromix Concreto - Assis', 'Noromix Concreto - Icém', 'Noromix Concreto - Itapura', 'Noromix Concreto - Monções', 'Noromix Concreto - Três Fronterias'] },
  { group: 'Construtora', units: ['Noromix Concreto - São Paulo'] },
  { group: 'Fábrica de Tubos', units: ['Noromix Concreto - Votuporanga'] },
  { group: 'Concreteiras', units: ['Noromix Concreto - Votuporanga', 'Noromix Concreto - Fernandópolis', 'Noromix Concreto - Jales', 'Noromix Concreto - Ilha Solteira', 'Noromix Concreto - Monções', 'Noromix Concreto - Ouroeste', 'Noromix Concreto - Paranaíba', 'Noromix Concreto - Três Fronteiras', 'Noromix Concreto - Pereira Barreto'] }
];

const ACCOUNT_PLAN_MAP = {
  '01': 'RECEITA BRUTA',
  '01.01': 'RECEITA BRUTA DE VENDAS/SERVIÇOS',
  '01.01.01': 'RECEITAS DE VENDAS',
  '01.02': 'OBRAS CONSTRUCAO CIVIL',
  '02': 'DEDUCOES',
  '02.01': 'DEDUCOES',
  '03': 'CUSTOS DIRETOS',
  '03.01': 'CUSTOS MÃO-DE-OBRA',
  '03.01.01': 'CUSTOS MAO-DE-OBRA (ENCARGOS)',
  '03.02': 'CUSTOS MATERIAIS',
  '03.02.01': 'CUSTOS MATERIAIS',
  '03.04': 'CUSTOS GERAIS / ADMINISTRATIVOS OBRA',
  '03.05': 'CUSTOS DE MANUTENCAO',
  '03.06': 'CUSTOS DE FRETE',
  '03.07': 'CUSTOS DE VEICULOS',
  '03.07.01': 'CUSTOS DE VEICULOS',
  '04': 'DESPESAS OPERACIONAIS',
  '04.01': 'DESPESA OPERACIONAL ADMINISTRATIVA',
  '04.01.01': 'MAO DE OBRA ADM',
  '04.01.02': 'MATERIAL DE CONSUMO OPERACIONAL ADM',
  '04.01.03': 'DESPESAS ADMINISTRATIVAS GERAIS',
  '04.02': 'DESPESAS FINANCEIRAS',
  '04.03': 'INDEDUTIVEIS',
  '04.04': 'MOVIMENTACAO BANCARIA / ADIANTAMENTOS',
  '05': 'IMPOSTOS',
  '05.01': 'IMPOSTOS',
  '06': 'ATIVO PERMANENTE / INVESTIMENTOS',
  '06.01': 'INVESTIMENTOS IMOBILIZADO',
  '07': 'FINANCIAMENTOS',
  '90': 'GASTOS INDUSTRIAIS',
  '95': 'RATEIO DE CUSTOS',
  '96': 'PROVISÕES A PAGAR'
};

const COST_CENTERS_LIST = [
  "01000 - ADMINISTRACAO",
  "01002 - DIRETORIA",
  "01006 - ENGENHARIA DE CAMPO",
  "01077 - SEGURANÇA DO TRABALHO - ADM",
  "00000 - GERAL / NÃO IDENTIFICADO"
];

const MONTHS = [
  'Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho',
  'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'
];

/**
 * ------------------------------------------------------------------
 * 2. GEMINI API INTEGRATION SERVICE
 * ------------------------------------------------------------------
 */
const geminiService = {
  generateFinancialInsight: async (contextData) => {
    const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
    const prompt = `Atue como um Controller Industrial. Analise: ${JSON.stringify(contextData)}. Gere um diagnóstico curto em Markdown.`;
    const payload = { contents: [{ parts: [{ text: prompt }] }] };
    return await geminiService.callApi(url, payload);
  },
  chatWithData: async (history, userMessage, contextData) => {
    const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
    const systemContext = `Dados Atuais: ${JSON.stringify(contextData)}. Responda sobre custos e produção.`;
    const prompt = `${systemContext}\n\nHistórico:\n${history.map(h => `${h.role}: ${h.text}`).join('\n')}\nUser: ${userMessage}\nModel:`;
    const payload = { contents: [{ parts: [{ text: prompt }] }] };
    return await geminiService.callApi(url, payload);
  },
  callApi: async (url, payload) => {
    try {
        const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        if (!response.ok) throw new Error('API Error');
        const data = await response.json();
        return data.candidates?.[0]?.content?.parts?.[0]?.text || "Sem resposta.";
    } catch (e) { return "Erro ao conectar com a IA."; }
  }
};

/**
 * ------------------------------------------------------------------
 * 3. CLOUD DATA SERVICE (Firestore)
 * ------------------------------------------------------------------
 */
const dbService = {
  getCollRef: (user, colName) => {
    if (!user) throw new Error("Usuário não autenticado");
    return collection(db, 'artifacts', appId, 'users', user.uid, colName);
  },
  addBulkTransactions: async (user, items) => {
    const chunkSize = 400;
    for (let i = 0; i < items.length; i += chunkSize) {
      const batch = writeBatch(db);
      const colRef = dbService.getCollRef(user, 'transactions');
      items.slice(i, i + chunkSize).forEach(item => batch.set(doc(colRef), item));
      await batch.commit();
    }
  },
  addTransaction: async (user, item) => { await addDoc(dbService.getCollRef(user, 'transactions'), item); },
  updateTransaction: async (user, id, data) => { await updateDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'transactions', id), data); },
  deleteTransaction: async (user, id) => { await deleteDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'transactions', id)); },
  getAllTransactions: async (user) => {
    const snapshot = await getDocs(dbService.getCollRef(user, 'transactions'));
    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
  },
  clearTransactions: async (user) => {
    const txs = await dbService.getAllTransactions(user);
    const chunkSize = 400;
    for (let i = 0; i < txs.length; i += chunkSize) {
      const batch = writeBatch(db);
      txs.slice(i, i + chunkSize).forEach(tx => batch.delete(doc(db, 'artifacts', appId, 'users', user.uid, 'transactions', tx.id)));
      await batch.commit();
    }
  },
  getSegments: async (user) => {
    const colRef = dbService.getCollRef(user, 'segments');
    const snapshot = await getDocs(colRef);
    let segs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    if (segs.length === 0) {
      await dbService.resetSegmentsToStandard(user); // Seed if empty
      const newSnapshot = await getDocs(colRef);
      segs = newSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    }
    return segs;
  },
  addSegment: async (user, name, group = 'Outros') => { await addDoc(dbService.getCollRef(user, 'segments'), { name, group }); },
  updateSegment: async (user, id, newName) => { await updateDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'segments', id), { name: newName }); },
  deleteSegment: async (user, id) => { await deleteDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'segments', id)); },
  resetSegmentsToStandard: async (user) => {
     const colRef = dbService.getCollRef(user, 'segments');
     const snapshot = await getDocs(colRef);
     const batchDel = writeBatch(db);
     snapshot.docs.forEach(doc => batchDel.delete(doc.ref));
     await batchDel.commit();
     const batchAdd = writeBatch(db);
     STANDARD_ORGANIZATION.forEach(group => {
         group.units.forEach(unitName => {
            const docRef = doc(colRef);
            batchAdd.set(docRef, { name: unitName, group: group.group });
         });
     });
     await batchAdd.commit();
  }
};

/**
 * ------------------------------------------------------------------
 * 4. PARSER LOGIC
 * ------------------------------------------------------------------
 */
const determineUnitFromCostCenter = (ccNumber) => {
  const num = parseInt(ccNumber, 10);
  if (isNaN(num)) return 'GERAL / INDEFINIDO'; 

  if (num >= 13000 && num <= 13999) return 'Porto de Areia Saara';
  if (num >= 14000 && num <= 14999) return 'Mineração Água Amarela';
  if (num >= 2000 && num <= 2999) return 'Mineração Noroeste Paulista - Monções';
  if (num >= 20000 && num <= 20999) return 'Mineração Grandes Lagos - Icém';
  if (num >= 5000 && num <= 5999) return 'Mineração Grandes Lagos - Itapura';
  if (num >= 4000 && num <= 4999) return 'Mineração Grandes Lagos - Riolândia';
  if (num >= 3000 && num <= 3999) return 'Mineração Grandes Lagos - Três Fronteiras';
  if (num >= 26000 && num <= 26999) return 'Noromix Concreto - Rinópolis'; 
  if (num >= 31000 && num <= 31999) return 'Noromix Concreto - Rinópolis'; 
  if (num >= 32000 && num <= 32999) return 'Noromix Concreto - Assis';
  if (num >= 21000 && num <= 21999) return 'Noromix Concreto - Icém';
  if (num >= 17000 && num <= 17999) return 'Noromix Concreto - Itapura';
  if (num >= 6000 && num <= 6999) return 'Noromix Concreto - Monções';
  if (num >= 7000 && num <= 7999) return 'Noromix Concreto - Três Fronterias';
  if (num >= 40000 && num <= 94999) return 'Noromix Concreto - São Paulo';
  if (num >= 10000 && num <= 10999) return 'Noromix Concreto - Votuporanga';
  if (num >= 8000 && num <= 8999) return 'Noromix Concreto - Votuporanga';
  if (num >= 27000 && num <= 27999) return 'Noromix Concreto - Fernandópolis';
  if (num >= 25000 && num <= 25999) return 'Noromix Concreto - Jales';
  if (num >= 29000 && num <= 29999) return 'Noromix Concreto - Ilha Solteira'; 
  if (num >= 34000 && num <= 34999) return 'Noromix Concreto - Monções';
  if (num >= 33000 && num <= 33999) return 'Noromix Concreto - Ouroeste';
  if (num >= 38000 && num <= 38999) return 'Noromix Concreto - Paranaíba';
  if (num >= 9000 && num <= 9999) return 'Noromix Concreto - Três Fronteiras';

  return 'OUTROS / SEM FAIXA';
};

const parseLegacyFile = (fileContent) => {
  const rawLines = fileContent.split('\n');
  const cleanTransactions = [];
  let buffer = [];
  const normalizedLines = [];
  
  rawLines.forEach((line) => {
    const trimmed = line.trim();
    if (!trimmed) return;
    if (/^\d{3,};/.test(trimmed)) {
      if (buffer.length > 0) normalizedLines.push(buffer.join(' '));
      buffer = [trimmed];
    } else {
      buffer.push(trimmed);
    }
  });
  if (buffer.length > 0) normalizedLines.push(buffer.join(' '));

  normalizedLines.forEach((fullLine) => {
    try {
      const cols = fullLine.split(';');
      let rawValue = cols[11] || "0"; 
      if (!/^\d+$/.test(rawValue)) {
          const potentialValue = cols.find(c => /0000\d+/.test(c) && c.length > 8);
          if (potentialValue) rawValue = potentialValue;
      }
      let value = parseInt(rawValue, 10) / 100;

      const dateMatch = fullLine.match(/(\d{2}\/\d{2}\/\d{4})/);
      const dateStr = dateMatch ? dateMatch[0] : new Date().toLocaleDateString();
      const [dd, mm, yyyy] = dateStr.split('/');
      const isoDate = `${yyyy}-${mm}-${dd}`;

      const ccRegex = /Centro de custo:\s*(\d+)/i;
      const ccMatch = fullLine.match(ccRegex);
      const ccNumber = ccMatch ? ccMatch[1] : '00000';
      
      const unitName = determineUnitFromCostCenter(ccNumber);

      const ccNameMatch = fullLine.match(/Centro de custo:\s*[\d\.]+\s*-\s*[\d\.]+\s*-\s*([^-]+)/i);
      let costCenterName = ccNameMatch ? ccNameMatch[1].trim() : 'GERAL';
      
      const supplier = cols[5]?.replace(/"/g, '').trim() || 'Fornecedor Desconhecido'; 
      const accountPlan = cols[7]?.replace(/"/g, '').trim() || '00.00'; 
      const planDescription = cols[8]?.replace(/"/g, '').trim() || 'Conta Diversa'; 

      let material = cols[48]?.replace(/"/g, '').trim() || '';
      if (/^0+$/.test(material)) material = '';

      const type = (accountPlan.startsWith('01.') || accountPlan.startsWith('4.') || planDescription.toUpperCase().includes('RECEITA')) ? 'revenue' : 'expense';

      if (value > 0) {
        cleanTransactions.push({
          date: isoDate,
          segment: unitName, 
          costCenter: costCenterName, 
          ccNumber: ccNumber, 
          accountPlan,
          planDescription, 
          description: supplier, 
          material: material, 
          value,
          type,
          source: 'file',
          createdAt: new Date().toISOString()
        });
      }
    } catch (err) {
      console.error("Erro linha:", err);
    }
  });

  return cleanTransactions;
};

/**
 * ------------------------------------------------------------------
 * 5. UI COMPONENTS
 * ------------------------------------------------------------------
 */
const KpiCard = ({ title, value, icon: Icon, color, trend, trendValue, subtitle }) => {
  const bgColors = {
    emerald: 'bg-emerald-50 text-emerald-600 border-emerald-100',
    rose: 'bg-rose-50 text-rose-600 border-rose-100',
    blue: 'bg-blue-50 text-blue-600 border-blue-100',
    indigo: 'bg-indigo-50 text-indigo-600 border-indigo-100',
    purple: 'bg-purple-50 text-purple-600 border-purple-100',
    amber: 'bg-amber-50 text-amber-600 border-amber-100'
  };
  const colorClass = bgColors[color] || bgColors.blue;

  return (
    <div className="bg-white dark:bg-slate-800 p-5 rounded-xl shadow-sm border border-slate-100 dark:border-slate-700 relative overflow-hidden group transition-all hover:shadow-md">
      <div className="flex justify-between items-start relative z-10">
        <div>
          <p className="text-xs font-bold text-slate-500 dark:text-slate-400 tracking-wide uppercase mb-1">{title}</p>
          <h3 className="text-2xl font-bold text-slate-800 dark:text-white">{value}</h3>
          {subtitle && <p className="text-xs text-slate-400 dark:text-slate-500 mt-1">{subtitle}</p>}
        </div>
        <div className={`p-2 rounded-lg ${colorClass} shadow-sm bg-opacity-10 dark:bg-opacity-20`}>
          <Icon size={20} strokeWidth={2} />
        </div>
      </div>
      {trend !== undefined && (
        <div className="mt-3 flex items-center text-xs font-medium relative z-10">
          <span className={`${trend >= 0 ? 'text-emerald-500' : 'text-rose-500'} flex items-center gap-1 px-1.5 py-0.5 rounded bg-opacity-10 ${trend >= 0 ? 'bg-emerald-50' : 'bg-rose-50'}`}>
            {trend >= 0 ? <TrendingUp size={12} /> : <TrendingDown size={12} />}
            {Math.abs(trend).toFixed(1)}%
          </span>
          <span className="text-slate-400 dark:text-slate-500 ml-2 truncate">{trendValue}</span>
        </div>
      )}
    </div>
  );
};

const HierarchyNode = ({ node, level = 0 }) => {
  const [expanded, setExpanded] = useState(level < 2); 
  const hasChildren = node.children && node.children.length > 0;
  const isRevenue = node.code.startsWith('01');
  const valueColor = isRevenue ? 'text-emerald-600 dark:text-emerald-400' : 'text-slate-700 dark:text-slate-200';
  
  return (
    <div className="border-b border-slate-50 dark:border-slate-700 last:border-0">
      <div 
        className={`flex items-center justify-between py-2 px-4 hover:bg-slate-50 dark:hover:bg-slate-700 cursor-pointer transition-colors 
        ${level === 0 ? 'bg-slate-100 dark:bg-slate-800 font-bold text-slate-900 dark:text-white' : ''} 
        ${level === 1 ? 'font-semibold bg-slate-50/50 dark:bg-slate-800/50 dark:text-slate-200' : 'dark:text-slate-300'}`}
        style={{ paddingLeft: `${level * 20 + 16}px` }}
        onClick={() => setExpanded(!expanded)}
      >
        <div className="flex items-center gap-2">
          {hasChildren ? (
            expanded ? <ChevronDown size={16} className="text-slate-400" /> : <ChevronRight size={16} className="text-slate-400" />
          ) : <span className="w-4"></span>}
          <span className="text-sm">
            <span className="text-slate-400 dark:text-slate-500 mr-2 font-mono text-xs bg-slate-100 dark:bg-slate-700 px-1 rounded">{node.code}</span>
            {node.name}
          </span>
        </div>
        <span className={`font-mono text-sm ${level===0 ? 'text-lg' : ''} ${valueColor}`}>
          {node.value.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}
        </span>
      </div>
      {expanded && hasChildren && (
        <div className="bg-white dark:bg-slate-800">
          {node.children.map(child => (
            <HierarchyNode key={child.code} node={child} level={level + 1} />
          ))}
        </div>
      )}
    </div>
  );
};

// Segment Manager UI
const SegmentManager = ({ onClose, segments, onUpdate, user }) => {
    const handleReset = async () => {
      if (confirm('Isso restaurará os segmentos padrão. Continuar?')) {
          await dbService.resetSegmentsToStandard(user);
          await onUpdate();
      }
    };
    return (
      <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 backdrop-blur-sm p-4">
         <div className="bg-white dark:bg-slate-800 rounded-xl p-6 shadow-xl w-full max-w-md">
             <h3 className="text-lg font-bold dark:text-white mb-4">Unidades e Segmentos</h3>
             <div className="max-h-60 overflow-y-auto mb-4 space-y-2">
                 {segments.map(s => <div key={s.id} className="p-2 border rounded dark:border-slate-600 dark:text-slate-300 text-sm">{s.name} <span className="text-xs text-slate-400 block">{s.group}</span></div>)}
             </div>
             <div className="flex justify-end gap-2">
                <button onClick={handleReset} className="text-xs text-indigo-600 dark:text-indigo-400 hover:underline mr-auto">Restaurar Padrões</button>
                <button onClick={onClose} className="px-4 py-2 bg-slate-200 dark:bg-slate-700 rounded text-slate-800 dark:text-white">Fechar</button>
             </div>
         </div>
      </div>
    );
};

// Manual Entry Modal
const ManualEntryModal = ({ onClose, segments, onSave, user, initialData }) => {
  const [type, setType] = useState('revenue');
  const [form, setForm] = useState({
    date: new Date().toISOString().substring(0, 7), 
    segment: segments[0]?.name || '',
    description: '', value: '', costCenter: 'RECEITA',
    prodMeta: '', prodReal: '', salesMeta: '', salesReal: '', stockQty: '', material: ''
  });

  const groupedSegments = useMemo(() => {
      const groups = {};
      segments.forEach(s => { const g = s.group || 'Outros'; if(!groups[g]) groups[g] = []; groups[g].push(s); });
      return groups;
  }, [segments]);

  useEffect(() => {
    if (initialData) {
      setType(initialData.type);
      setForm({
        date: initialData.date ? initialData.date.substring(0, 7) : '',
        segment: initialData.segment,
        description: initialData.description || '',
        value: initialData.value?.toString() || '',
        costCenter: initialData.costCenter,
        prodMeta: initialData.prodMeta || '', prodReal: initialData.prodReal || '',
        salesMeta: initialData.salesMeta || '', salesReal: initialData.salesReal || '',
        stockQty: initialData.stockQty || '', material: initialData.material || ''
      });
    }
  }, [initialData]);

  const handleSubmit = async () => {
    if (!user) return;
    if (type !== 'operational' && !form.value) return;
    
    const transaction = {
      date: `${form.date}-01`,
      segment: form.segment,
      description: type === 'operational' ? 'Métricas Operacionais' : form.description,
      value: type === 'operational' ? 0 : parseFloat(form.value),
      type: type,
      source: 'manual',
      costCenter: form.costCenter,
      createdAt: new Date().toISOString(),
      prodMeta: parseFloat(form.prodMeta || 0), prodReal: parseFloat(form.prodReal || 0),
      salesMeta: parseFloat(form.salesMeta || 0), salesReal: parseFloat(form.salesReal || 0),
      stockQty: parseFloat(form.stockQty || 0),
      material: form.material
    };

    if (initialData?.id) { await dbService.updateTransaction(user, initialData.id, transaction); } 
    else { await dbService.addTransaction(user, transaction); }
    onSave(); onClose();
  };

  if (!user) return null;

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 backdrop-blur-sm p-4">
      <div className="bg-white dark:bg-slate-800 rounded-xl shadow-xl w-full max-w-lg p-6 overflow-y-auto max-h-[90vh]">
        <div className="flex justify-between items-center mb-6">
            <h3 className="text-xl font-bold text-slate-800 dark:text-white">{initialData ? 'Editar' : 'Novo'} Lançamento</h3>
            <button onClick={onClose}><X className="text-slate-400" /></button>
        </div>
        <div className="grid grid-cols-3 gap-2 mb-6 bg-slate-100 dark:bg-slate-700 p-1 rounded-lg">
            {['revenue', 'expense', 'operational'].map(t => (
                <button key={t} onClick={() => setType(t)} className={`py-2 rounded-md text-sm font-medium capitalize ${type === t ? 'bg-white dark:bg-slate-600 shadow-sm text-indigo-600 dark:text-white' : 'text-slate-500 dark:text-slate-400'}`}>
                    {t === 'operational' ? 'Métricas' : t === 'revenue' ? 'Receita' : 'Despesa'}
                </button>
            ))}
        </div>
        <div className="space-y-4">
             <div><label className="text-xs text-slate-500 dark:text-slate-400 block mb-1">Data</label><input type="month" className="w-full border rounded p-2 dark:bg-slate-700 dark:text-white dark:border-slate-600" value={form.date} onChange={e => setForm({...form, date: e.target.value})} /></div>
             <div><label className="text-xs text-slate-500 dark:text-slate-400 block mb-1">Unidade</label><select className="w-full border rounded p-2 dark:bg-slate-700 dark:text-white dark:border-slate-600" value={form.segment} onChange={e => setForm({...form, segment: e.target.value})}>{Object.entries(groupedSegments).map(([group, items]) => (<optgroup key={group} label={group}>{items.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}</optgroup>))}</select></div>
             
             {type !== 'operational' && (
                 <>
                    <div><label className="text-xs text-slate-500 dark:text-slate-400 block mb-1">Descrição</label><input className="w-full border rounded p-2 dark:bg-slate-700 dark:text-white dark:border-slate-600" value={form.description} onChange={e => setForm({...form, description: e.target.value})} /></div>
                    <div><label className="text-xs text-slate-500 dark:text-slate-400 block mb-1">Valor (R$)</label><input type="number" className="w-full border rounded p-2 dark:bg-slate-700 dark:text-white dark:border-slate-600" value={form.value} onChange={e => setForm({...form, value: e.target.value})} /></div>
                 </>
             )}
             
             {type === 'operational' && (
                 <>
                    <div className="grid grid-cols-2 gap-2">
                        <div><label className="text-xs text-slate-500 dark:text-slate-400 block mb-1">Meta Prod.</label><input type="number" className="w-full border rounded p-2 dark:bg-slate-700 dark:text-white dark:border-slate-600" value={form.prodMeta} onChange={e => setForm({...form, prodMeta: e.target.value})} /></div>
                        <div><label className="text-xs text-slate-500 dark:text-slate-400 block mb-1">Real Prod.</label><input type="number" className="w-full border rounded p-2 dark:bg-slate-700 dark:text-white dark:border-slate-600" value={form.prodReal} onChange={e => setForm({...form, prodReal: e.target.value})} /></div>
                    </div>
                    <div className="grid grid-cols-2 gap-2">
                        <div><label className="text-xs text-slate-500 dark:text-slate-400 block mb-1">Meta Vendas</label><input type="number" className="w-full border rounded p-2 dark:bg-slate-700 dark:text-white dark:border-slate-600" value={form.salesMeta} onChange={e => setForm({...form, salesMeta: e.target.value})} /></div>
                        <div><label className="text-xs text-slate-500 dark:text-slate-400 block mb-1">Real Vendas</label><input type="number" className="w-full border rounded p-2 dark:bg-slate-700 dark:text-white dark:border-slate-600" value={form.salesReal} onChange={e => setForm({...form, salesReal: e.target.value})} /></div>
                    </div>
                    <div><label className="text-xs text-slate-500 dark:text-slate-400 block mb-1">Estoque (Qtd)</label><input type="number" className="w-full border rounded p-2 dark:bg-slate-700 dark:text-white dark:border-slate-600" value={form.stockQty} onChange={e => setForm({...form, stockQty: e.target.value})} /></div>
                 </>
             )}

             <button onClick={handleSubmit} className="w-full bg-indigo-600 text-white py-2 rounded hover:bg-indigo-700">Salvar</button>
        </div>
      </div>
    </div>
  );
};

// AI Analysis & Chat Assistant components kept simplified for length
const AIAnalysisModal = ({ onClose, report, isLoading }) => { return <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4"><div className="bg-white dark:bg-slate-800 p-6 rounded-xl max-w-2xl w-full max-h-[80vh] overflow-y-auto"><div className="flex justify-between mb-4"><h3 className="font-bold text-lg dark:text-white">Relatório IA</h3><button onClick={onClose}><X/></button></div>{isLoading ? <Loader2 className="animate-spin mx-auto"/> : <div className="prose dark:prose-invert">{report.split('\n').map((l,i)=><p key={i}>{l}</p>)}</div>}</div></div>; };
const ChatAssistant = ({ contextData }) => { const [open, setOpen] = useState(false); return <>{!open && <button onClick={()=>setOpen(true)} className="fixed bottom-4 right-4 bg-indigo-600 text-white p-3 rounded-full shadow-lg"><Bot/></button>}</>; };

/**
 * ------------------------------------------------------------------
 * 6. MAIN APP COMPONENT
 * ------------------------------------------------------------------
 */
export default function App() {
  const [user, setUser] = useState(null);
  const [isAuthLoading, setIsAuthLoading] = useState(true);
  const [authError, setAuthError] = useState(null);
  const [darkMode, setDarkMode] = useState(localStorage.getItem('theme') === 'dark');
  const [sidebarOpen, setSidebarOpen] = useState(true);

  const [activeTab, setActiveTab] = useState('dashboard');
  const [transactions, setTransactions] = useState([]);
  const [segments, setSegments] = useState([]);
  const [globalFilter, setGlobalFilter] = useState('ALL');
  const [filterYear, setFilterYear] = useState(new Date().getFullYear());
  const [filterPeriod, setFilterPeriod] = useState('month');
  const [filterMonth, setFilterMonth] = useState(new Date().getMonth());
  
  // Hierarchy Filter
  const [hierarchyPeriod, setHierarchyPeriod] = useState('month');

  // Detailed Costs Filters
  const [detailStartDate, setDetailStartDate] = useState('');
  const [detailEndDate, setDetailEndDate] = useState('');
  const [detailSupplier, setDetailSupplier] = useState('');
  const [detailAccount, setDetailAccount] = useState('');
  
  const [showSegmentManager, setShowSegmentManager] = useState(false);
  const [showEntryModal, setShowEntryModal] = useState(false);
  const [editingTransaction, setEditingTransaction] = useState(null);
  const [showAIModal, setShowAIModal] = useState(false);
  const [aiReport, setAiReport] = useState('');
  const [isAiLoading, setIsAiLoading] = useState(false);
  const [importText, setImportText] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const fileInputRef = useRef(null);

  useEffect(() => {
    const initAuth = async () => {
      try {
        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
           await signInWithCustomToken(auth, __initial_auth_token);
        } else {
           await signInAnonymously(auth);
        }
      } catch (err) {
        console.error("Auth failed", err);
        setAuthError("Falha na conexão com o banco de dados.");
        setIsAuthLoading(false);
      }
    };
    initAuth();
    const unsubscribe = onAuthStateChanged(auth, (u) => {
      setUser(u);
      if(u) setAuthError(null);
      setIsAuthLoading(false);
    });
    return () => unsubscribe();
  }, []);

  useEffect(() => {
      if (darkMode) document.documentElement.classList.add('dark');
      else document.documentElement.classList.remove('dark');
      localStorage.setItem('theme', darkMode ? 'dark' : 'light');
  }, [darkMode]);

  const loadData = async () => {
    if (!user) return;
    try {
        const txs = await dbService.getAllTransactions(user);
        const segs = await dbService.getSegments(user);
        let filtered = txs.sort((a, b) => new Date(b.date) - new Date(a.date));
        if (globalFilter !== 'ALL') {
           const targetGroupUnits = STANDARD_ORGANIZATION.find(g => g.group === globalFilter)?.units || [];
           filtered = filtered.filter(t => t.segment === globalFilter || targetGroupUnits.includes(t.segment));
        }
        setTransactions(filtered);
        setSegments(segs);
    } catch(err) { console.error("Data load failed", err); }
  };

  useEffect(() => { if (user) loadData(); }, [user, globalFilter, activeTab]);

  const availableYears = useMemo(() => {
    const years = new Set(transactions.map(t => new Date(t.date).getFullYear()));
    years.add(new Date().getFullYear());
    return Array.from(years).sort((a, b) => b - a);
  }, [transactions]);

  const availableCostCenters = useMemo(() => {
    const ccs = new Set(transactions.map(t => t.costCenter));
    return Array.from(ccs).sort();
  }, [transactions]);

  const isDateInPeriod = (dateStr, periodType) => {
      const d = new Date(dateStr); const year = d.getFullYear(); const month = d.getMonth(); 
      if (year !== parseInt(filterYear)) return false;
      switch(periodType) {
        case 'month': return month === parseInt(filterMonth);
        case 'q1': return month >= 0 && month <= 2;
        case 'q2': return month >= 3 && month <= 5;
        case 'q3': return month >= 6 && month <= 8;
        case 'q4': return month >= 9 && month <= 11;
        case 's1': return month >= 0 && month <= 5;
        case 's2': return month >= 6 && month <= 11;
        case 'year': return true;
        default: return true;
      }
  };

  const filteredTransactions = useMemo(() => transactions.filter(t => isDateInPeriod(t.date, filterPeriod)), [transactions, filterPeriod, filterMonth, filterYear]);
  const manualTransactions = useMemo(() => transactions.filter(t => t.source === 'manual'), [transactions]);

  const detailedTransactions = useMemo(() => {
      return transactions.filter(t => {
         if (t.type === 'operational') return false;
         if (detailStartDate && t.date < detailStartDate) return false;
         if (detailEndDate && t.date > detailEndDate) return false;
         if (detailSupplier && !t.description.toLowerCase().includes(detailSupplier.toLowerCase())) return false;
         if (detailAccount && !t.planDescription.toLowerCase().includes(detailAccount.toLowerCase()) && !t.accountPlan.includes(detailAccount)) return false;
         if (!detailStartDate && !detailEndDate) {
             return isDateInPeriod(t.date, filterPeriod);
         }
         return true;
      }).sort((a,b) => new Date(b.date) - new Date(a.date));
  }, [transactions, detailStartDate, detailEndDate, detailSupplier, detailAccount, filterPeriod, filterMonth, filterYear]);

  const kpiData = useMemo(() => {
      let currRev = 0, currExp = 0, prodReal = 0, salesReal = 0;
      let prevRev = 0, prevExp = 0;
      const costCenters = {};

      filteredTransactions.forEach(t => {
        if (t.type === 'revenue') currRev += t.value;
        else if (t.type === 'expense') { currExp += t.value; costCenters[t.costCenter] = (costCenters[t.costCenter] || 0) + t.value; }
        else if (t.type === 'operational') { prodReal += (t.prodReal || 0); salesReal += (t.salesReal || 0); }
      });
      
      const unitCost = prodReal > 0 ? (currExp / prodReal) : 0;
      const calcTrend = (curr, prev) => prev === 0 ? 0 : ((curr - prev) / prev) * 100;
      const topExpenses = Object.entries(costCenters).map(([name, value]) => ({ name, value: value.toLocaleString('pt-BR', {style:'currency', currency:'BRL'}) })).sort((a,b) => parseFloat(b.value.replace(/\D/g,'')) - parseFloat(a.value.replace(/\D/g,''))).slice(0, 3);

      return { revenue: currRev, expense: currExp, balance: currRev - currExp, revTrend: calcTrend(currRev, prevRev), expTrend: calcTrend(currExp, prevExp), prodReal, salesReal, unitCost, topExpenses };
  }, [filteredTransactions]);

  const hierarchyData = useMemo(() => {
      let filteredTxs = transactions.filter(t => t.type !== 'operational' && isDateInPeriod(t.date, hierarchyPeriod));
      
      const map = {};
      Object.keys(ACCOUNT_PLAN_MAP).forEach(code => { map[code] = { code, name: ACCOUNT_PLAN_MAP[code], value: 0, isLeaf: false, children: [] }; });
      filteredTxs.forEach(t => {
        const code = t.accountPlan || '99.99';
        if (!map[code]) map[code] = { code, name: t.planDescription, value: 0, isLeaf: true, children: [] };
        else map[code].isLeaf = true;
        map[code].value += t.value;
      });
      const rootNodes = [];
      const processNode = (fullCode) => {
        const parts = fullCode.split('.'); let currentCode = ''; let parent = null;
        parts.forEach((part, idx) => {
          currentCode = currentCode ? `${currentCode}.${part}` : part;
          if (!map[currentCode]) { const fallbackName = ACCOUNT_PLAN_MAP[currentCode] || `CONTA ${currentCode}`; map[currentCode] = { code: currentCode, name: fallbackName, value: 0, children: [], isLeaf: false }; }
          if (parent) { if (!parent.children.find(c => c.code === currentCode)) parent.children.push(map[currentCode]); }
          else { if (!currentCode.includes('.') && !rootNodes.find(n => n.code === currentCode)) rootNodes.push(map[currentCode]); }
          parent = map[currentCode];
        });
      };
      Object.keys(map).sort().forEach(code => processNode(code));
      const sumNodes = (node) => { if (node.children && node.children.length > 0) { const sum = node.children.reduce((acc, child) => acc + sumNodes(child), 0); node.value = sum + (node.isLeaf ? node.value : 0); return node.value; } return node.value; };
      rootNodes.forEach(n => sumNodes(n));
      return rootNodes.sort((a, b) => a.code.localeCompare(b.code));
  }, [transactions, hierarchyPeriod, filterYear, filterMonth]);

  const chartDataYearly = useMemo(() => {
      const monthly = {};
      for(let i=0; i<12; i++) { const key = `${filterYear}-${String(i+1).padStart(2, '0')}`; monthly[key] = { name: MONTHS[i].substring(0,3), fullMonth: MONTHS[i], Receita: 0, Despesa: 0 }; }
      transactions.forEach(t => {
          if (t.type === 'operational') return;
          const d = new Date(t.date);
          if (d.getFullYear() === parseInt(filterYear)) {
              const key = `${filterYear}-${String(d.getMonth()+1).padStart(2, '0')}`;
              if (monthly[key]) { if (t.type === 'revenue') monthly[key].Receita += t.value; else monthly[key].Despesa += t.value; }
          }
      });
      return Object.values(monthly);
  }, [transactions, filterYear]);

  const productionSalesData = useMemo(() => {
    const monthly = {};
    for(let i=0; i<12; i++) { const key = `${filterYear}-${String(i+1).padStart(2, '0')}`; monthly[key] = { name: MONTHS[i].substring(0,3), fullMonth: MONTHS[i], prodMeta: 0, prodReal: 0, salesMeta: 0, salesReal: 0 }; }
    transactions.filter(t => t.type === 'operational').forEach(t => {
        const d = new Date(t.date);
        if (d.getFullYear() === parseInt(filterYear)) {
            const key = `${filterYear}-${String(d.getMonth()+1).padStart(2, '0')}`;
            if (monthly[key]) { monthly[key].prodMeta += t.prodMeta || 0; monthly[key].prodReal += t.prodReal || 0; monthly[key].salesMeta += t.salesMeta || 0; monthly[key].salesReal += t.salesReal || 0; }
        }
    });
    return Object.values(monthly);
  }, [transactions, filterYear]);

  const stockData = useMemo(() => {
      const data = [];
      for(let i=0; i<12; i++) { 
          const label = MONTHS[i].substring(0,3);
          const monthTx = transactions.filter(t => {
             const d = new Date(t.date);
             return t.type === 'operational' && d.getFullYear() === parseInt(filterYear) && d.getMonth() === i;
          }).sort((a,b) => new Date(b.createdAt) - new Date(a.createdAt))[0]; 
          data.push({ name: label, stock: monthTx ? monthTx.stockQty : 0 });
      }
      return data;
  }, [transactions, filterYear]);
  
  const currentStock = useMemo(() => {
      const sortedOps = filteredTransactions.filter(t => t.type === 'operational
